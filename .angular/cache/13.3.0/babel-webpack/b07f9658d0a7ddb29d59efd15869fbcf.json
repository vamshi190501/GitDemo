{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError, from } from 'rxjs';\nimport { delay, materialize, dematerialize, concatMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\"; // array in local storage for accounts\n\nconst accountsKey = 'angular-10-facebook-login-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request; // wrap in delayed observable to simulate server api call\n\n      return handleRoute();\n\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      } // route functions\n\n\n      function authenticate() {\n        const {\n          accessToken\n        } = body;\n        return from(new Promise(resolve => {\n          fetch(`https://graph.facebook.com/v8.0/me?access_token=${accessToken}`).then(response => resolve(response.json()));\n        })).pipe(concatMap(data => {\n          if (data.error) return unauthorized(data.error.message);\n          let account = accounts.find(x => x.facebookId === data.id);\n\n          if (!account) {\n            // create new account if first time logging in\n            account = {\n              id: newAccountId(),\n              facebookId: data.id,\n              name: data.name,\n              extraInfo: `This is some extra info about ${data.name} that is saved in the API`\n            };\n            accounts.push(account);\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n          }\n\n          return ok(Object.assign(Object.assign({}, account), {\n            token: generateJwtToken(account)\n          }));\n        }));\n      }\n\n      function getAccounts() {\n        if (!isLoggedIn()) return unauthorized();\n        return ok(accounts);\n      }\n\n      function getAccountById() {\n        if (!isLoggedIn()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        return ok(account);\n      }\n\n      function updateAccount() {\n        if (!isLoggedIn()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id === idFromUrl()); // update and save account\n\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(account);\n      }\n\n      function deleteAccount() {\n        if (!isLoggedIn()) return unauthorized(); // delete account then save\n\n        accounts = accounts.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      } // helper functions\n\n\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500));\n      }\n\n      function unauthorized(message = 'Unauthorized') {\n        return throwError({\n          status: 401,\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n\n      function isLoggedIn() {\n        var _a;\n\n        return (_a = headers.get('Authorization')) === null || _a === void 0 ? void 0 : _a.startsWith('Bearer fake-jwt-token');\n      }\n\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n\n      function generateJwtToken(account) {\n        // create token that expires in 15 minutes\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n    }\n\n  }\n\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)();\n  };\n\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module"}